using Blok3Game.Engine.JSON;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;
using System.Linq;
using SocketIOClientClass = SocketIOClient.SocketIO;
using System.Threading.Tasks;
using SocketIO.Serializer.SystemTextJson;
using System.Text.Json;
using SocketIOClient;

namespace Blok3Game.Engine.SocketIOClient
{
    public class SocketClient
    {
		/// <summary>
		/// More information about the C# SocketIOClient can be found here:
		/// https://github.com/doghappy/socket.io-client-csharp
		/// </summary>
        private SocketIOClientClass client;
		
		/// <summary>
		/// The session data that is received from the server when the session is established.
		/// This is used to restore the session when the connection is momentarily lost.
		/// When the client is closed, the session is lost.
		/// </summary>
        private SessionData sessionData;
		
		/// <summary>
		/// A queue of dataPackets that is used to send dataPackets that were sent before the client was connected.
		/// </summary>
		/// <remarks>
		/// This is needed because the client needs to be connected before it can send dataPackets.
		/// </remarks>
        private Queue<DataPacket> queuedDataPackets = new Queue<DataPacket>();
		
		/// <summary>
		/// The instance of the SocketClient. This is a singleton.
		/// This is used to make sure that there is only one instance of the SocketClient that is used throughout the game
		/// and can be accessed from anywhere.
		/// More information about the singleton pattern can be found here:
		/// https://www.c-sharpcorner.com/UploadFile/8911c4/singleton-design-pattern-in-C-Sharp/
		/// </summary>
        private static SocketClient instance = new SocketClient();

        #region EVENTS
		/// <summary>
		/// A delegate that is used to invoke the event handlers. More information about delegates can be found here:
		/// https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/
		/// </summary>
		/// <typeparam name="T"> 
		/// The type of the dataPacket that is received. This is used to make sure that the dataPacket is cast to the correct type.
		/// Only classes that inherit from DataPacket can be used here. 
		/// </typeparam>
		/// <param name="item">
		/// The JSON response from the server that is parsed to a DataPacket.
		/// </param>
	
		private delegate void DelegateDataPacketReceived<T>(T item) where T : DataPacket, new();
		/// <summary>
		/// A dictionary that is used to store the event handlers. 
		/// The key is the type of the dataPacket that is received.
		/// The value is a list of event handlers that are invoked when the dataPacket is received.
		/// </summary>
        
		private Dictionary<Type, List<DelegateDataPacketReceived<DataPacket>>> eventHandlers;
        #endregion

		/// <summary>
		/// The room id of the room the user is currently in. Empty if the user is not in a room.
		/// </summary>
        public string RoomId { get; set; } = string.Empty;

		/// <summary>
		/// The user id of the user that is currently playing. This id is unique for each user and is generated by the server.
		/// This id is only available after the session has been established. This happens when the systems connects to the server.
		/// Session is stored by the server in a session cookie. When the connection is lost, the session will be restored. 
		/// When the client is closed, the session is lost.
		/// </summary>
        public string UserId => sessionData.UserId;

		/// <summary>
		/// The session id of the session that is currently active. This id is unique for each session and is generated by the server.
		/// </summary>
        public string SessionId => sessionData.SessionId;

		/// <summary>
		/// The instance of the SocketClient. This is a singleton. Use this accessor to get the instance of the SocketClient.
		/// Any other use of this class will result in an error.
		/// </summary>
        public static SocketClient Instance => instance;

		/// <summary>
		/// This constuctor is static, so it executes only once.
		/// More information about static constructors can be found here:
		/// https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-constructors
		/// </summary>
		static SocketClient()
		{
		}

		/// <summary>
		/// the constructor is private so that it can only be called from within the class.
		/// </summary>
        private SocketClient() 
		{
			// Read the server address from the ServerLocation.txt file.
			// This file is located in the Content folder.
			// The file contains the location and path of the server for both debug and release mode.
			ServerAddressReader.ServerAddress serverAddress = ServerAddressReader.Read();
			string location = serverAddress.Location;
			string path = serverAddress.Path;
			
			client = new SocketIOClientClass(location, new SocketIOOptions { Path = path })
			{
				/// <summary>
				/// C# naming conventions (PascalCase) are different from the JSON naming conventions (camelCase).
				/// Options are set to make sure that the JSON response from the server is mapped to the correct properties.
				/// </summary>
				Serializer = new SystemTextJsonSerializer(new JsonSerializerOptions
				{
					PropertyNamingPolicy = JsonNamingPolicy.CamelCase
				})
			};
		}

		/// <summary>
		/// Initializes the SocketClient. This method is called from the static constructor.
		/// This method is marked async (asyncronous) because it needs to connect to the server.
		/// It is uncertain how long this will take, so this method will wait for the connection to be established
		/// before continuing with the rest of the code.
		/// </summary>
        public async void Initialize()
        {
            eventHandlers = new Dictionary<Type, List<DelegateDataPacketReceived<DataPacket>>>();
			
            SubscribeToAssemblyTypes();

			//Connect to the socket server and wait for the connection to be established.
			//This is done because the client needs to be connected before it can send dataPackets.
            await ConnectToSocketServer();

            //All dataPackets that were sent before the client was connected are sent now, in order.
			//The order is guaranteed because the dataPackets are stored in a queue.
			//A queue is a data structure that stores data in the order it was added.
			//More information about queues can be found here:
			//https://www.programiz.com/dsa/queue
            SendQueuedDataPackets();

			//In both cases, when the connection is established or re-established, the queued dataPackets are sent that 
			//were sent before the connection was established.
            client.OnConnected += (object sender, EventArgs e) => SendQueuedDataPackets();
            client.OnReconnected += (object sender, int e) => SendQueuedDataPackets();
        }

		/// <summary>
		/// Subscribes to a specific dataPacket. Can only be used by classes that inherit from DataPacket.
		/// When the dataPacket is received, the onDataReceived method is called.
		/// Make sure the dataPacket has a parameterless constructor, that the <see cref="DataPacket.EventName"/> 
		/// is set to the matching event name in the server, and that the JSON naming conventions are followed.
		/// </summary>
		/// <typeparam name="T">A subtype of DataPacket</typeparam>
		/// <param name="onDataReceived">A function with only one parameter; the subtype provided as generic parameter</param>
        public void SubscribeToDataPacket<T>(Action<T> onDataReceived) where T : DataPacket, new()
        {
            Type type = typeof(T);
            eventHandlers[type].Add((DataPacket dataPacket) => onDataReceived.Invoke((T)dataPacket));
        }

		/// <summary>
		/// Unsubscribes from a specific dataPacket. Can only be used by classes that inherit from DataPacket.
		/// </summary>
		/// <typeparam name="T">A subtype of DataPacket</typeparam>
		/// <param name="onDataReceived">A function with only one parameter; the subtype provided as generic parameter</param>
        public void UnsubscribeFromDataPacket<T>(Action<T> onDataReceived) where T : DataPacket, new()
        {
            Type type = typeof(T);
            eventHandlers[type].Remove((DataPacket dataPacket) => onDataReceived.Invoke((T)dataPacket));
        }

		/// <summary>
		/// Sends a dataPacket to the server. 
		/// Make sure the dataPacket has a parameterless constructor, that the EventName is set,
		/// that it is a subtype of DataPacket, and that the JSON naming conventions are followed.
		/// </summary>
        public void SendDataPacket(DataPacket dataPacket)
        {
            if (dataPacket.EventName == null)
            {
                throw new Exception("DataPacket has no EventName");
            }

            //if the client is connected, send the dataPacket. If not, add it to the queue to be sent at a later time.
            if (client.Connected)
            {
                client.EmitAsync(dataPacket.EventName, dataPacket);
            }
            else
            {
                queuedDataPackets.Enqueue(dataPacket);
            }
        }

		/// <summary>
		/// Subscribes to all dataPackets that are in the assembly and that are a (cascading) subtype of DataPacket,
		/// have a parameterless constructor, and are not abstract.
		/// </summary>
        private void SubscribeToAssemblyTypes()
        {
            IEnumerable<Type> assemblyTypes = AppDomain.CurrentDomain.GetAssemblies()
			.SelectMany(assembly => assembly.GetTypes())
			.Where((type) => 
			{
				Type derived = type;
				do
				{ 
					derived = derived.BaseType;
					if (derived != null)
					{
						//Check if the type is a DataPacket, is not abstract and has a parameterless constructor.
						if (derived == typeof(DataPacket) && !type.IsAbstract && type.GetConstructor(Type.EmptyTypes) != null)
						{
							return true;
						}
					}
				} while (derived != null);
				return false;
			});

            foreach (Type assemblyType in assemblyTypes.ToList())
            {
                MethodInfo method = GetType().GetMethod(nameof(HandleIncomingDataPackets), BindingFlags.NonPublic | BindingFlags.Instance);
                MethodInfo generic = method.MakeGenericMethod(assemblyType);
                generic.Invoke(this, [new Action<DataPacket>(OnDataReceivedHandler)]);
            }
        }

		/// <summary>
		/// Subscribes to a specific dataPacket type. Whenever the event with the matching name is received, 
		/// the onDataReceived method is called.
		/// </summary>
		/// <typeparam name="T">The type of DataPacket to listen for</typeparam>
		/// <param name="onDataReceived">A function with only one parameter; the subtype provided as generic parameter</param>
		/// <exception cref="FormatException">Thrown if the datapacket has no EventName</exception>
        private void HandleIncomingDataPackets<T>(Action<T> onDataReceived) where T : DataPacket, new()
        {
            string eventName = new T().EventName;
            Type type = typeof(T);
            AddEventHandler<T>();

            if (eventName == null)
            {
                throw new FormatException("DataPacket has no EventName");
            }

            client.On(eventName, (resp) =>
            {
				try
				{
					T dataPacket = resp.GetValue<T>();
					onDataReceived.Invoke(dataPacket);
				} catch (Exception e)
				{
					Debug.WriteLine($"Be sure to follow the JSON naming conventions and that it can be mapped on {type.Name}: {e}");
				}
            });
        }

		/// <summary>
		/// Receives the dataPacket and invokes the event handlers that are subscribed to the dataPacket.
		/// </summary>
		/// <param name="dataPacket">The dataPacket that was received by the client.</param>
        private void OnDataReceivedHandler(DataPacket dataPacket)
        {
            eventHandlers.TryGetValue(dataPacket.GetType(), out List<DelegateDataPacketReceived<DataPacket>> handlers);
            handlers.ForEach(handler => handler.Invoke(dataPacket));
        }

		/// <summary>
		/// Adds an event handler to the dictionary of event handlers.
		/// </summary>
        private void AddEventHandler<T>() where T : DataPacket
        {
            Type type = typeof(T);
            if (!eventHandlers.ContainsKey(type))
            {
                eventHandlers.Add(type, new List<DelegateDataPacketReceived<DataPacket>>());
            }
        }

		/// <summary>
		/// Sends all datapackets that were queued before the client was connected.
		/// </summary>
        private void SendQueuedDataPackets()
        {
            while (queuedDataPackets.Count > 0)
            {
                DataPacket dataPacket = queuedDataPackets.Dequeue();
                SendDataPacket(dataPacket);
            }
        }

		/// <summary>
		/// Receives and stores the session data from the server when the session is established.
		/// </summary>
		private void OnSessionEstablished(SessionData sessionData)
		{
			this.sessionData = sessionData;
			client.Options.Query = new Dictionary<string, string>
			{
				{ "sessionId", sessionData.SessionId }
			};
		}

		/// <summary>
		/// Disconnects the client from the server.
		/// </summary>
		public void Disconnect()
		{
			client.Dispose();
		}

		/// <summary>
		/// Connects to the socket server and subscribes to the dataPackets.
		/// It is uncertain how long this will take, so this method will wait for the connection to be established.
		/// Therefore, it is marked async (asyncronous).
		/// </summary>
		/// <returns></returns>
        private async Task ConnectToSocketServer() 
        {
			// Subscribe to the session data and error messages. 
			// Once the session is established, the session data is stored.
            SubscribeToDataPacket<SessionData>(OnSessionEstablished);
            SubscribeToDataPacket<ErrorData>(HandleErrorMessage);
            await client.ConnectAsync();
        }

        private void HandleErrorMessage(ErrorData error)
        {
            throw new NetworkException("Error: " + error.Reason);
        }
    }
}